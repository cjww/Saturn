#version 420
#extension GL_ARB_compute_shader : enable

layout (local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0, rgba8) uniform readonly image2D smallImage;  
layout(set = 0, binding = 1, rgba8) uniform readonly image2D bigImage;
layout(set = 0, binding = 2, rgba8) uniform writeonly image2D resultImage;


vec4 upsample(ivec2 coordinate) {
    vec4 s;
	s =  imageLoad(smallImage, ivec2(coordinate + ivec2(1, 1)));
    s += imageLoad(smallImage, ivec2(coordinate + ivec2(0, 1))) * 2.0;
    s += imageLoad(smallImage, ivec2(coordinate + ivec2(-1, 1)));
    s += imageLoad(smallImage, ivec2(coordinate + ivec2(1, 0))) * 2.0;
    s += imageLoad(smallImage, ivec2(coordinate				 )) * 4.0;
    s += imageLoad(smallImage, ivec2(coordinate + ivec2(-1, 0))) * 2.0;
    s += imageLoad(smallImage, ivec2(coordinate + ivec2(1, -1)));
    s += imageLoad(smallImage, ivec2(coordinate + ivec2(0, -1))) * 2.0;
    s += imageLoad(smallImage, ivec2(coordinate + ivec2(-1, -1)));

    return s * (1.0 / 16.0);
}

void main() {
    ivec2 posBig = ivec2(gl_GlobalInvocationID.xy);
	ivec2 posSmall = ivec2(posBig / 2);

	//vec4 finalColor = upsample(posSmall, vec4(1), vec2(1));
	//finalColor += imageLoad(bigImage, posBig);

	vec4 finalColor = upsample(posSmall);
	finalColor += imageLoad(bigImage, posBig);
	//vec4 finalColor = imageLoad(smallImage, posSmall) + imageLoad(bigImage, posBig);

	/*
	//vec4 color = imageLoad(smallImage, posSmall) + imageLoad(bigImage, posBig);
	
	vec4 finalColor = vec4(0);
	finalColor += imageLoad(smallImage, posSmall + ivec2(-1, 0));
	finalColor += imageLoad(smallImage, posSmall + ivec2(1, 0));
	finalColor += imageLoad(smallImage, posSmall + ivec2(0, -1));
	finalColor += imageLoad(smallImage, posSmall + ivec2(0, 1));
	finalColor += imageLoad(smallImage, posSmall);
	
	
	finalColor = finalColor * (1.0 / 5.0);

	finalColor += imageLoad(bigImage, posBig);
	*/

	imageStore(resultImage, posBig, vec4(finalColor.rgb, 1.0));
	
}