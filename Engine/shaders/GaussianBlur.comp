#version 420
#extension GL_ARB_compute_shader : enable
layout (local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0, rgba8) uniform readonly image2D inputImage;  
layout(set = 0, binding = 1, rgba8) uniform writeonly image2D resultImage;

float normpdf(in float x, in float sigma)
{
	return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;
}

vec3 gaussian(ivec2 pos) {
	//declare stuff
	const int mSize = 7;
	const int kSize = (mSize-1)/2;
	float kernel[mSize];
	vec3 final_colour = vec3(0.0);
	
	//create the 1-D kernel
	float sigma = 7.0;
	float Z = 0.0;
	for (int j = 0; j <= kSize; ++j)
	{
		kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);
	}
	
	//get the normalization factor (as the gaussian has been clamped)
	for (int j = 0; j < mSize; ++j)
	{
		Z += kernel[j];
	}
	
	//read out the texels
	for (int i=-kSize; i <= kSize; ++i) {
		for (int j=-kSize; j <= kSize; ++j) {
			ivec2 samplePos = pos + ivec2(i, j);
			samplePos *= 2;
			final_colour += kernel[kSize+j]*kernel[kSize+i] * imageLoad(inputImage, samplePos).rgb;
		}
	}
	return final_colour / (Z*Z);
}

// [Jimenez14] http://goo.gl/eomGso
// . . . . . . .
// . A . B . C .
// . . D . E . .
// . F . G . H .
// . . I . J . .
// . K . L . M .
// . . . . . . .
vec4 downsample(ivec2 coordinate) {
	vec4 A = imageLoad(inputImage, coordinate + ivec2(-1.0, -1.0));
    vec4 B = imageLoad(inputImage, coordinate + ivec2( 0.0, -1.0));
    vec4 C = imageLoad(inputImage, coordinate + ivec2( 1.0, -1.0));
    vec4 D = imageLoad(inputImage, coordinate + ivec2(-0.5, -0.5));
    vec4 E = imageLoad(inputImage, coordinate + ivec2( 0.5, -0.5));
    vec4 F = imageLoad(inputImage, coordinate + ivec2(-1.0,  0.0));
    vec4 G = imageLoad(inputImage, coordinate               		);
    vec4 H = imageLoad(inputImage, coordinate + ivec2( 1.0,  0.0));
    vec4 I = imageLoad(inputImage, coordinate + ivec2(-0.5,  0.5));
    vec4 J = imageLoad(inputImage, coordinate + ivec2( 0.5,  0.5));
    vec4 K = imageLoad(inputImage, coordinate + ivec2(-1.0,  1.0));
    vec4 L = imageLoad(inputImage, coordinate + ivec2( 0.0,  1.0));
    vec4 M = imageLoad(inputImage, coordinate + ivec2( 1.0,  1.0));

    vec2 div = 0.25 * vec2(0.5, 0.125);

    vec4 o = (D + E + I + J) * div.x;
    o += (A + B + G + F) * div.y;
    o += (B + C + H + G) * div.y;
    o += (F + G + L + K) * div.y;
    o += (G + H + M + L) * div.y;

    return o;
}

void main() {
	/*

	ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
	ivec2 posInputImage = pos * 2;

	imageStore(resultImage, pos, vec4(finalColor.xyz, 1.0));
	*/
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
 	//vec4 finalColor = downsample(pos * 2);
    vec3 finalColor = gaussian(pos);
	//vec3 finalColor = imageLoad(inputImage, pos * 2).xyz;

	imageStore(resultImage, pos, vec4(finalColor, 1.0));
	/*

	
	ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 posInputImage = pos * 2;
	vec4 finalColor = vec4(0);

	finalColor += imageLoad(inputImage, posInputImage + ivec2(-1, 1));
	finalColor += imageLoad(inputImage, posInputImage + ivec2(1, 1));
	finalColor += imageLoad(inputImage, posInputImage + ivec2(-1, -1));
	finalColor += imageLoad(inputImage, posInputImage + ivec2(1, -1));
	finalColor = finalColor * 0.25;

	imageStore(resultImage, pos, finalColor);
	*/
	/*
	ivec2 resultPos = ivec2(gl_GlobalInvocationID.xy);
	ivec2 inputPos = resultPos * 2;
	ivec2 inputImageExtent = textureSize(inputImage, 0);
	vec2 uv = inputPos / vec2(inputImageExtent);

	vec4 color = texture(inputImage, uv);
	imageStore(resultImage, resultPos, color);
	*/

}