#version 430

#define MAX_LIGHTS_PER_TILE 4096
#define TILE_SIZE 16

struct AABB {
	vec3 center;
	vec3 extents;
};

struct Light {
    vec4 color;
    vec3 position;
    float intensity;
	float attenuationRadius;
    uint type;
};

layout(set = 0, binding = 2, std430) readonly buffer Lights {
    uint lightCount;
    Light lights[];
} lightBuffer;

layout(set = 0, binding = 1, std430) writeonly buffer LightIndices {
	uint data[];
} lightIndices;

layout(set = 0, binding = 0) uniform sampler2D depthMap;  

layout(push_constant) uniform PushConstants {
	mat4 projection;
	mat4 view;
} pc;

// Shared values between all the threads in the group
shared uint minDepthInt;
shared uint maxDepthInt;
shared uint visibleLightCount;
shared vec4 frustumPlanes[6];
// Shared local storage for visible indices, will be written out to the global buffer at the end
shared int visibleLightIndices[MAX_LIGHTS_PER_TILE];
shared mat4 viewProjection;

// Took some light culling guidance from Dice's deferred renderer
// http://www.dice.se/news/directx-11-rendering-battlefield-3/

bool sphereAABBIntersect(vec3 sphereCenter, float radius, AABB aabb) {
	vec3 vDelta = max(abs(aabb.center - sphereCenter) - aabb.extents, 0);
	float fDistSq = dot(vDelta, vDelta);
	return fDistSq <= radius * radius;
}

float linearizeDepth(float d, mat4 projection) {
	//return (0.5 * projection[3][2]) / (d + 0.5 * projection[2][2] - 0.5);
	// We are only interested in the depth here
	vec4 ndcCoords = vec4(0, 0, d, 1);

	mat4 invProj = inverse(projection);
	// Unproject the vector into (homogenous) view-space vector
	vec4 viewCoords = invProj * ndcCoords;

	// Divide by w, which results in actual view-space z value
	return viewCoords.z / viewCoords.w;
}

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE, local_size_z = 1) in;
void main() {
	ivec2 location = ivec2(gl_GlobalInvocationID.xy);
	ivec2 tileID = ivec2(gl_WorkGroupID.xy);
	ivec2 tileNumber = ivec2(gl_NumWorkGroups.xy);
	uint index = tileID.y * tileNumber.x + tileID.x;

	// Initialize shared global values for depth and light count
	if (gl_LocalInvocationIndex == 0) {
		minDepthInt = 0xFFFFFFFF;
		maxDepthInt = 0;
		visibleLightCount = 0;
		viewProjection = pc.projection * pc.view;
	}

	barrier();

	// Step 1: Calculate the minimum and maximum depth values (from the depth buffer) for this group's tile
	ivec2 screenSize = textureSize(depthMap, 0);
	vec2 text = vec2(location) / screenSize;
	float depth = texture(depthMap, text).r;
	// Linearize the depth value from depth buffer (must do this because we created it using projection)
	depth = linearizeDepth(depth, pc.projection);
	
	// Convert depth to uint so we can do atomic min and max comparisons between the threads
	uint depthInt = floatBitsToUint(depth);
	atomicMin(minDepthInt, depthInt);
	atomicMax(maxDepthInt, depthInt);
	float minDepth, maxDepth;
	
	barrier();
	minDepth = uintBitsToFloat(minDepthInt);
	maxDepth = uintBitsToFloat(maxDepthInt);

	// Step 2: One thread should calculate the frustum planes to be used for this tile
	if (gl_LocalInvocationIndex == 0) {
		// Convert the min and max across the entire tile back to float
	
		vec2 tileTopLeftClipSpace = 1 - (2.0 * tileID / tileNumber); // [1, -1]
		vec2 tileSizeClipSpace = 1 / (tileNumber * 0.5);
		
		frustumPlanes[0] = vec4(1.0, 0.0, 0.0, tileTopLeftClipSpace.x) * viewProjection; // Left
		frustumPlanes[1] = vec4(-1.0, 0.0, 0.0, -(tileTopLeftClipSpace.x - tileSizeClipSpace.x)) * viewProjection; // Right
		frustumPlanes[2] = vec4(0.0, 1.0, 0.0, tileTopLeftClipSpace.y) * viewProjection; // Bottom
		frustumPlanes[3] = vec4(0.0, -1.0, 0.0, -(tileTopLeftClipSpace.y - tileSizeClipSpace.y)) * viewProjection; // Top

		frustumPlanes[4] = vec4(0.0, 0.0, 1.0, maxDepth) * pc.view; // Far
		frustumPlanes[5] = vec4(0.0, 0.0, -1.0, -minDepth) * pc.view; // Near
	
		for(int i = 0; i < 6; i++) {
			frustumPlanes[i] /= length(frustumPlanes[i].xyz);
		}
	
	}

	barrier();

	// Step 3: Cull lights.
	// Parallelize the threads against the lights now.
	// Can handle 256 simultaniously. Anymore lights than that and additional passes are performed
	uint threadCount = TILE_SIZE * TILE_SIZE;
	uint passCount = (lightBuffer.lightCount + threadCount - 1) / threadCount;
	for (uint i = 0; i < passCount; i++) {
		// Get the lightIndex to test for this thread / pass. If the index is >= light count, then this thread can stop testing lights
		uint lightIndex = i * threadCount + gl_LocalInvocationIndex;
		if (lightIndex >= lightBuffer.lightCount) {
			break;
		}

		vec4 position = vec4(lightBuffer.lights[lightIndex].position, 1);
		vec4 lightPosClipSpace = pc.view * position;
		//lightPosClipSpace /= lightPosClipSpace.w;
		//lightPosClipSpace /= length(lightPosClipSpace.xyz);
		float lightDepth = lightPosClipSpace.z;
		//lightDepth = linearizeDepth(lightDepth, pc.projection);
		
		float radius = lightBuffer.lights[lightIndex].attenuationRadius;
		
		// We check if the light exists in our frustum
		float dist = 0.0;
		
		if(lightDepth + radius >= maxDepth &&
			lightDepth - radius <= minDepth) {
			for (uint j = 0; j < 4; j++) {
				dist = dot(position, frustumPlanes[j]) + radius;

				// If one of the tests fails, then there is no intersection
				if (dist < 0.0) {
					break;
				}
			}
		}

		// If greater than zero, then it is a visible light
		if (dist > 0.0) {

			// Add index to the shared array of visible indices
			uint offset = atomicAdd(visibleLightCount, 1);
			visibleLightIndices[offset] = int(lightIndex);
		}
	}

	barrier();

	// One thread should fill the global light buffer
	if (gl_LocalInvocationIndex == 0) {
		uint offset = index * MAX_LIGHTS_PER_TILE; // Determine bosition in global buffer
		for (uint i = 0; i < visibleLightCount; i++) {
			lightIndices.data[offset + i] = visibleLightIndices[i];
		}

		if (visibleLightCount != MAX_LIGHTS_PER_TILE) {
			// Unless we have totally filled the entire array, mark it's end with -1
			// Final shader step will use this to determine where to stop (without having to pass the light count)
			lightIndices.data[offset + visibleLightCount] = -1;
		}
	}
}