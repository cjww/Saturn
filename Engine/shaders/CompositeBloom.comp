#version 420
#extension GL_ARB_compute_shader : enable
layout (local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0) uniform sampler2D colorImage;  
layout(set = 0, binding = 1, rgba8) uniform readonly image2D bloomImage;
layout(set = 0, binding = 2, rgba8) uniform readonly image2D toneMapping;

layout(set = 0, binding = 3, rgba8) uniform writeonly image2D resultImage;


vec4 upsample(ivec2 coordinate, vec4 sampleScale) {

	vec4 d = vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;

    vec4 s;
    s =  imageLoad(bloomImage, ivec2(coordinate - d.xy));
    s += imageLoad(bloomImage, ivec2(coordinate - d.wy)) * 2.0;
    s += imageLoad(bloomImage, ivec2(coordinate - d.zy));
    s += imageLoad(bloomImage, ivec2(coordinate + d.zw)) * 2.0;
    s += imageLoad(bloomImage, ivec2(coordinate       )) * 4.0;
    s += imageLoad(bloomImage, ivec2(coordinate + d.xw)) * 2.0;
    s += imageLoad(bloomImage, ivec2(coordinate + d.zy));
    s += imageLoad(bloomImage, ivec2(coordinate + d.wy)) * 2.0;
    s += imageLoad(bloomImage, ivec2(coordinate + d.xy));

    return s * (1.0 / 16.0);
}


void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
	ivec2 colorImageExtent = textureSize(colorImage, 0);
	vec2 uv = vec2(pos) / vec2(colorImageExtent);
	vec4 color = texture(colorImage, uv);
	
	ivec2 bloomPos = pos;
	vec4 bloom = upsample(bloomPos, vec4(1));

	imageStore(resultImage, pos, color + bloom);
}