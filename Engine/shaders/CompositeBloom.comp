#version 420
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable
layout (local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0) uniform sampler2D colorImage;  
layout(set = 0, binding = 1, rgba8) uniform readonly image2D bloomImage;
layout(set = 0, binding = 2, rgba8) uniform readonly image2D toneMapping;

layout(set = 0, binding = 3, rgba8) uniform writeonly image2D resultImage;

/*
layout(set = 0, binding = 4) uniform BloomInfo {
    float intensity;
    float spread;
} bloomInfo;

layout(set = 0, binding = 5) uniform TonemapInfo {
    int mode;
    float gamma;
    float exposure;
} tonemapInfo;
*/


vec4 upsample(ivec2 coordinate) {
    vec4 s;
	s =  imageLoad(bloomImage, ivec2(coordinate + ivec2(1, 1)));
    s += imageLoad(bloomImage, ivec2(coordinate + ivec2(0, 1))) * 2.0;
    s += imageLoad(bloomImage, ivec2(coordinate + ivec2(-1, 1)));
    s += imageLoad(bloomImage, ivec2(coordinate + ivec2(1, 0))) * 2.0;
    s += imageLoad(bloomImage, ivec2(coordinate				 )) * 4.0;
    s += imageLoad(bloomImage, ivec2(coordinate + ivec2(-1, 0))) * 2.0;
    s += imageLoad(bloomImage, ivec2(coordinate + ivec2(1, -1)));
    s += imageLoad(bloomImage, ivec2(coordinate + ivec2(0, -1))) * 2.0;
    s += imageLoad(bloomImage, ivec2(coordinate + ivec2(-1, -1)));

    return s * (1.0 / 16.0);
}


vec4 reinhard(vec4 color, float key, float white) {
    float luminance = dot(color, vec4(0.2126, 0.7152, 0.0722, 0));
    float result = (luminance * (1.0 + (luminance / (white * white))) ) / (luminance + 1.0);
    return vec4(result, result, result, 1.0);
}

vec4 filmicToneMapping(vec4 color) {
    vec3 x = color.rgb;
    vec3 result = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);
    return vec4(result, 1.0);
}

vec3 FilmicTonemapping(vec3 color, float exposure, float whitePoint)
{
    vec3 linearColor = pow(color / 12.92, vec3(2.2));
    vec3 x = max(vec3(0), linearColor - 0.004);
    vec3 curve = (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);
    vec3 tonemappedColor = curve * (1. / 2.51) * (exposure * whitePoint);
    vec3 sRGBcolor = pow(tonemappedColor, vec3(1.0 / 2.2));
    return sRGBcolor;
}

vec3 reinhard(vec3 v) {
    return v / (1.0 + v);
}

float luminance(vec3 v) {
    return dot(v, vec3(0.2126, 0.7152, 0.0722));
}

vec3 change_luminance(vec3 c_in, float l_out) {
    float l_in = luminance(c_in);
    return c_in * (l_out / l_in);
}

vec3 reinhard_extended_luminance(vec3 v, float max_white_l) {
    float l_old = luminance(v);
    float numerator = l_old * (1.0 + (l_old / (max_white_l * max_white_l)));
    float l_new = numerator / (1.0 + l_old);
    return change_luminance(v, l_new);
}

vec3 aces_approx(vec3 v) {
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);
}

vec3 uncharted2_tonemap_partial(vec3 x)
{
    float A = 0.15;
    float B = 0.50;
    float C = 0.10;
    float D = 0.20;
    float E = 0.02;
    float F = 0.30;
    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

vec3 uncharted2_filmic(vec3 v)
{
    float exposure_bias = 2.0;
    vec3 curr = uncharted2_tonemap_partial(v * exposure_bias);

    vec3 W = vec3(11.2);
    vec3 white_scale = vec3(1.0) / uncharted2_tonemap_partial(W);
    return curr * white_scale;
}

vec4 gammaCorrect(vec4 color, float gamma) {
    return pow(color, vec4(1.0 / gamma));
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
	ivec2 colorImageExtent = textureSize(colorImage, 0);
	
	vec2 uv = pos / vec2(colorImageExtent);
	vec4 color = texture(colorImage, uv);
    
    // add Bloom
	vec4 bloom = upsample(ivec2(pos * 0.5));
    color += bloom;
   
    // Tonemapping
    //color = color * filmicToneMapping(color);
    //color.rgb = FilmicTonemapping(color.rgb, 0.1, 1.0);
    //color = color * reinhard(color, 0.18, 1.0);
    //color.rgb = reinhard(color.rgb);
	//color.rgb = reinhard_extended_luminance(color.rgb, 600);
    //color.rgb = uncharted2_filmic(color.rgb);
    float exposure = 0.6;
    color.rgb *= exposure;
    color.rgb = aces_approx(color.rgb);
    color = gammaCorrect(color, 2.2);


    imageStore(resultImage, pos, vec4(color.rgb, 1.0));
}